<!DOCTYPE html>
<html>

<head>
    <title>RTI Viewer - Framer Compatible</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="skin.css" />

    <style>
        html, body {
            margin: 0px;
            padding: 0px;
            height: 100%;
            /* Scroll problemini çözmek için overflow'u serbest bırakıyoruz */
            overflow: visible !important; 
            background: black;
        }

        #demo {
            position: relative;
            width: 100%;
            height: 100%; /* Embed alanına tam oturması için */
            background: black;
            /* Dokunmatik cihazlarda sayfa kaydırmayı engellememesi için */
            touch-action: pan-y !important;
        }

        /* Tüm OpenLIME arayüz elemanlarını CSS ile temizle */
        .openlime-toolbar, .openlime-menu, .openlime-sidebar, 
        .openlime-topbar, .openlime-footer, .openlime-controls, 
        .openlime-menu-button, .openlime-panel, .openlime-lightdir { 
            display: none !important; 
        }

        canvas {
            cursor: crosshair;
            /* Mouse tekerleğinin tarayıcıya iletilmesini sağlar */
            pointer-events: auto;
        }
    </style>
</head>

<body>
    <div id="demo" class="openlime"></div>
</body>

<script src="openlime.min.js"></script>

<script>
// RTI Algılama Fonksiyonları (Korundu)
async function autodetect() {
    let response = await fetch('plane_0.tzi');
    if(response.status == 200) return "tarzoom";
    response = await fetch('plane_0.dzi');
    if(response.status == 200) return "deepzoom";
    response = await fetch('planes.tzi');
    if(response.status == 200) return "itarzoom";
    response = await fetch('plane_0.jpg');
    if(response.status == 200) return "image";
    return "";
}

async function autodetectNormals(layout) {
    let checkUrls = { 'tarzoom': 'normals.tzi', 'deepzoom': 'normals.dzi', 'image': 'normals.jpg' };
    if (checkUrls[layout]) {
        let response = await fetch(checkUrls[layout]);
        return response.status == 200;
    }
    return false;
}

async function init() {
    const layout = await autodetect();
    const normals = await autodetectNormals(layout);
    
    // Viewer başlatma
    const lime = new OpenLIME.Viewer('#demo', { background:'black' });

    // Ana RTI Katmanı
    const layer = new OpenLIME.Layer({ 
        layout: layout, 
        type:'rti',
        url: 'info.json',
        normals: normals
    });
    lime.canvas.addLayer('RTI', layer); 

    // Vektör Katmanı (Her zaman aktif)
    const vectorLayer = new OpenLIME.Layer({
        type: 'image',
        url: 'vector.png',
        overlay: true,
        visible: true
    });
    lime.canvas.addLayer('vector', vectorLayer);

    // UI Ayarları
    OpenLIME.Skin.setUrl('skin.svg');
    const ui = new OpenLIME.UIBasic(lime, { skin: 'skin.svg', showLightDirections: false });

    // Menüleri kapat
    Object.keys(ui.actions).forEach(key => {
        if (ui.actions[key]) ui.actions[key].display = false;
    });

    // Zoom özelliğini kökten kapat
    lime.camera.maxFixedZoom = 0;
    lime.camera.minFixedZoom = 0;

    // Işık butonu aktif ama tıklama kontrolü kapalı (Otomatik mod için)
    ui.actions.light.active = true;
    if (ui.actions.light) {
        ui.actions.light.mouseControl = false; 
    }

    // --- KRİTİK SCROLL ÇÖZÜMÜ ---
    // OpenLIME'ın tekerlek olaylarını "yutmasını" engelliyoruz
    const container = document.getElementById('demo');
    
    // Kütüphanenin wheel listener'larını etkisiz hale getir
    lime.canvas.ui.onwheel = null;
    lime.canvas.canvas.onwheel = null;
    
    // Tarayıcıya tekerleği serbest bırakması için pasif dinleyici ekle
    container.addEventListener('wheel', (e) => {
        // Fonksiyon boş: Sadece event'in yukarı (Framer'a) çıkmasına izin verir
    }, { passive: true });

    // --- OTOMATİK IŞIK TAKİBİ ---
    container.addEventListener('mousemove', (ev) => {
        const rect = container.getBoundingClientRect();
        const x = (ev.clientX - rect.left) / rect.width;
        const y = (ev.clientY - rect.top) / rect.height;
        
        const px = 2 * Math.max(0, Math.min(1, x)) - 1;
        const py = 2 * (1 - Math.max(0, Math.min(1, y))) - 1;

        if (ui.lightcontroller && ui.lightcontroller.setPosition) {
            ui.lightcontroller.setPosition(px, py);
        }
    });

    window.lime = lime;
}

init();
</script>

</html>